#!/usr/bin/python3
"""
Merges multiple Hydrogeosphere-ASCII Tecplot output files into one.

USAGE:
    hgs-merge-tp-domains.py [FILE_NAMES]

If FILE_NAMES is omitted, equivalent command is
    hgs-merge-tp-domains.py <batch.pfx>o.pm.dat <batch.pfx>o.frac.dat
    

Inputs:
    >= 2 Tecplot ASCII format data files generated by Tecplot

Output:
    A single Tecplot ASCII-format file with each of the input
    files assigned to a separate zone strand.  Only the
    variables (e.g.  "X", "Y", "Z", "Zone", "Head", "Vx", "Vy",
    "Vz", "salt", etc.) common to all files are provided in output.

    Output goes to <prefix>o.dat if no command line arguments specified.
    Otherwise, output goes to console. Capture console output via redirection
    e.g.
      hgs-merge-tp-domains.py tpfile1.dat tpfile2.dat > tpfileout.dat

Ken Walton
February 2015
November 2018

Fixes: 
- rename several variables to common names (between frac.dat and pm.dat;
        common vars in dual.dat seem to have the same names as in pm.dat)
"""

import sys,re,copy,itertools

TPCOMM='#' # tecplot comment character

# Variables appear with different names, different places in the HGS output.
# This dictionary attempts to convert the alias names to a normalized name.
# Alias names are on the left hand side of :'s. Aliases should be lowercase. If
# aliases have multiple words, use a single space between the words.
normVarName = {
    'x':'X','y':'Y','z':'Z',
    'zone':'Zone',
    'depth2gwt':'Depth2GWT',
    'saturation':"Sat", 'sat':"Sat",
    "head":"Head",
    'kxx':'Kxx', 'kyy':'Kyy', 'kzz':'Kzz',
    'vx':'Vx', 'vy':'Vy', 'vz':'Vz',
    'x linear velocity':'Vx', 'y linear velocity':'Vy', 'z linear velocity':'Vz',
    '3dnode#':'3DNode#','3d node #':'3DNode#',
    'cl':'Cl',
    'tce':'TCE',
    'aperture':'Ap'
}
normVarName_maxWords = max( len(v.split()) for v in normVarName.keys() )

class HGSTPReaderWriter:
    """ 
        The only thing (so far) that makes this an HGS reader/writer is the
        dependence on the format of the variables string
    """

    title=""

    def __init__( self, fn ):
        self.fn = fn

        # placeholders for some things we'll precompute for the zone header
        # lines
        self.strandId = -1
        self.varLocString = None
        self.varShareString = None
        self.ovNonShared = set()


        # open the file
        self.f = open(self.fn, 'r')

        # read the title lines
        line = self.f.readline()
        while not line.startswith('TITLE'):
            line = self.f.readline()
        while line.startswith('TITLE'):
            self.title += line.strip()+"\n"
            line = self.f.readline()
        self.title = self.title.strip()

        # read/parse the variable line
        while not line.startswith('VARIABLES'):
            line = self.f.readline()
        self.variables = HGSTPReaderWriter._parseVariables( line )

        # file pointer should be at the beginning of the first zone

    def __del__(self):
        self.f.close()


    def getVariablesLine( self ):
        return 'VARIABLES ="'+'","'.join(self.variables)+'"'

    def setVariables(self, varSet):
        self.oldVariables = copy.copy(self.variables)
        self.variables = list( filter( lambda v: v in varSet, self.oldVariables ) )

        # precompute the oldVariables index -> new variable index
        # for fixing the VARSHARELIST and CONNECTIVITYSHAREZONE zone header
        # entries
        self.ov2nv = dict(
            map(
                lambda v: (self.oldVariables.index(v[1])+1, v[0]),
                enumerate(self.variables,start=1)
            )
        )

        def indexOf( ov ):
           i='skipped'
           try:
              i = str( self.variables.index(ov)+1 )
           except ValueError:
              pass
           return i
         
        self.ov2nvStr = ", ".join(
              "{}={}".format( ov, indexOf(ov) ) for ov in self.oldVariables ) 

    def _makeRenumberedVarString(self, oldVarIndString):
        """from the string containing indices from the input file,
        convert them to the new variable index values, if they will exist in the
        new file"""
        ovil = list( int(s) for s in oldVarIndString.split(',') )
        return ', '.join(
            list(
                map( lambda oi: str(self.ov2nv[oi]),
                    filter( lambda oi: oi in self.ov2nv, ovil )
                )
            )
        )

    def _fixZoneHeader_setZoneOutVars(self, badZoneLine):
        #assumes this only has one group in VARSHARELIST
        #assumes this only has one group in VARLOCATION


        # fix the CONNECTIVITYSHAREZONE
        m = re.match('(.*)CONNECTIVITYSHAREZONE=\d*(.*)',badZoneLine)
        if m:
            badZoneLine = "{}CONNECTIVITYSHAREZONE={}{}".format(
                m.group(1), self.firstZone, m.group(2) )


        # fix the indices in VARLOCATION
        m = re.match('(.*)VARLOCATION=\(\[(.*?)\]=(\S+)\)(.*)',badZoneLine)
        #              \1                  \2       \3    \4
        if m:
            # redo the string
            if not self.varLocString:
                self.varLocString = self._makeRenumberedVarString( m.group(2) )
            badZoneLine = "{}VARLOCATION=([{}]={}){}".format(
                m.group(1), self.varLocString, m.group(3), m.group(4) )


        # keep all variables in this zone for output. update below
        self.ovNonShared = set( self.ov2nv.keys() )

        # fix the indices in and attached zone in VARSHARELIST
        m = re.match('(.*)VARSHARELIST=\(\[(.*?)\]\)(.*)',badZoneLine)
        #              \1                   \2       \3
        if m:
            # redo the string
            if not self.varShareString:
                self.varShareString = self._makeRenumberedVarString( m.group(2) )
            badZoneLine = "{}VARSHARELIST=([{}]={}){}".format(
                m.group(1), self.varShareString, self.firstZone, m.group(3) )

            # keep only the non-shared variables in this zone for output
            self.ovNonShared.difference_update( set( int for v in m.group(2).split(",") ) )



        # add the strand info
        goodZoneLine = badZoneLine + " STRANDID={}".format(self.strandId)


        return goodZoneLine




    def writezones(self, strandId, zonesBefore, fout):
        """Write the zones contained in the file to fout and return the number
            of zones written
            
        Assumes that zones are to be written in the same order as in the
        variables list.
        Assumes that zones are in Block format.
        Assumes that a comment with the variable name precedes each block.
        """

        self.strandId = strandId
        self.firstZone = zonesBefore + 1
        extra = "SHAREZONE={} STRANDID={}".format(zonesBefore+1,strandId)

        zoneCount = 0       # current zone number in this strand
        varCount  = 0       # variable number in the current zone
        printData = False   # flag for outputting data lines corresponding to
                            # the current variable in the current zone
        
        # for element and connectivity lists applicable to FEBRICK, etc
        firstZONETYPEvar = len(self.oldVariables)+1

        # process the data file line by line
        # look for ZONE header lines or comments to change the behaviour of each
        # iteration of the loop
        for l in self.f:

            if l.startswith('ZONE'):
                print(self._fixZoneHeader_setZoneOutVars(l.strip()),file=fout)
                zoneCount += 1
                varCount = 0

            elif l.startswith(TPCOMM):
                # toggle printing of this variable
                
                varCount += 1

                # set the printData flag == True if this variable gets put to
                # output file
                if varCount >= firstZONETYPEvar :
                    # will only  be true for first zone of each file
                    printData = True

                else:
                    # examine the comment and see if it's a variable we want
                    varComment = l[len(TPCOMM):].strip()
                    varNumber = self.oldVariables.index(
                            HGSTPReaderWriter._normalizeVarName(varComment))+1

                    printData = varNumber in self.ovNonShared

                # print the comment line
                if printData: print(l.strip(), file=fout)

            else:
                # print the data line if printData==True
                # or skip it
                if printData: print(l.strip(), file=fout)
            
        return zonesBefore + zoneCount

    @staticmethod
    def _normalizeVarName( vn ):
        vnsplit = vn.lower().split()

        vnprefix=vnsplit[0]
        if vnprefix in normVarName:
            return normVarName[vnprefix]

        for nextpart in vnsplit[1:normVarName_maxWords]:
            vnprefix += " "+nextpart
            if vnprefix in normVarName:
                return normVarName[vnprefix]

        raise Exception( "Found a new (supposed) variable name '{}'. Add it to the script's dictionary!".format(vn) )


    @staticmethod
    def _parseVariables( l ):
        """return a list containing the variable names in the order of
            appearance in the file"""

        #return list( re.match('VARIABLES ="(.*?)","\1.*', l.strip()).groups())
        # Should use an RE
        varList = l[len('VARIABLES ='):].strip()[1:-1].split('","')
        return list( map( HGSTPReaderWriter._normalizeVarName, varList ) )


    @staticmethod
    def mergeTo( tpfiles, fout=sys.stdout ):

        # Find out which variables are common between all the files
        # Assumes that variables are in the same order
        commonVars = set( tpfiles[0].variables )
        for f in tpfiles[1:]:   commonVars.intersection_update(set(f.variables))
        for f in tpfiles:       f.setVariables( commonVars )
        # TODO: make sure variables are in the same order!

        # print the list of files we're merging
        FN_WID=max( ( map(lambda f: len(f.fn), tpfiles ) ) )
        mergeInfo = '{0:} merge of: \n{0:}   {1:}'.format(
              TPCOMM, "\n{} + ".format(TPCOMM).join(
                 "{:{w}} VARIABLES: {}".format(k.fn,k.ov2nvStr,w=FN_WID) for k in tpfiles))
        print(mergeInfo, file=fout)
        print(mergeInfo, file=sys.stderr)

        # print the title of the first file -- should be the same for all files,
        # as it's the title that is generated from the grok file
        print( tpfiles[0].title, file=fout )


        # print the common header
        print( tpfiles[0].getVariablesLine(), file=fout )


        # iterate the list of ReaderWriters and spew their data.
        zoneCount = 0
        for strandId,f in enumerate(tpfiles,start=1):
            zoneCount += f.writezones(strandId, zoneCount, fout)

if __name__ == "__main__":
    
    prefix=None
    mergeReaderWriters = []

    if len(sys.argv) == 1:
        with open('batch.pfx','r') as f:
            prefix = f.readline().strip()
        mergeReaderWriters.append(  HGSTPReaderWriter( prefix+'o.pm.dat' ) )
        mergeReaderWriters.append(  HGSTPReaderWriter( prefix+'o.frac.dat' ) )
        with open(prefix+'o.dat','w') as f:
            HGSTPReaderWriter.mergeTo( mergeReaderWriters, fout=f)

    else:
        mergeReaderWriters = list(map(HGSTPReaderWriter, sys.argv[1:]))
        HGSTPReaderWriter.mergeTo( mergeReaderWriters, fout=sys.stdout)

