#!/usr/bin/env python
"""Run Monte Carlo-style realization of a Hydrogeosphere problem

Examples:
    Run 5 variants on ../base_sim/. Creates ./mc1, ..., ./mc5. 
    $ python hgs-mc.py 5 ../base_sim

Dependencies:
    - hgs-copy-inputs.py (for copying base_sim)
    - pre- and post-processing scripts in base_sim to set up a new realization

    - pycf.ancillary.TextManip

"""
import sys
import os
import argparse
import shutil
import shlex
import time
import glob
import subprocess
from itertools import chain
from datetime import datetime
from multiprocessing import Pool
from math import ceil,log10

from pyhgs.runner import PyPowerShellRunner

import logging

logger = logging.getLogger(__name__)
logger.addHandler(logging.StreamHandler())
logger.verbose2 = lambda msg : logger.log(logging.INFO-2,msg)
logger.verbose3 = lambda msg : logger.log(logging.INFO-3,msg)

# Useful:
#https://wiseodd.github.io/techblog/2016/06/13/parallel-monte-carlo/



class HGS_MCRunner():

    def __init__(self, copy_command, tc_command, base_dir):

        self.RUN_START = datetime.now()
        """Time of object creation. Assuming that one HGS_MCRunner object is
        made per monte carlo run, this timestamp can be a unique identifier for
        this run."""

        self.DRY_RUN = False
        """Skip running Hydrogeosphere, hgs-runall. This may (will) have have
        consequences in subsequent analysis steps, as there may not (will not)
        be any output to analyze."""

        self._instance = {}
        """Hash the names of the instances that have been set up"""

        self.copy_command = shlex.split(copy_command)
        """Program and arguments needed to copy the simulation inputs"""
        if self.copy_command[0].lower().endswith('.py'):
            self.copy_command.insert(0,'python')
            self.copy_command[1] = shutil.which(self.copy_command[1])

        self.tc_command = tc_command
        """Program and arguments needed to run the tool chain."""

        self.base_sim_dir = base_dir
        """Directory containing base simulation that will be copied to MC
        directories"""
    
    def gen_mc_instances(self, n):
        """
        """
        width = int(ceil(log10(n)))
        for i in range(n):
            s=self._make_mc_run_tag('{ii:0>{w}d}'.format(ii=i,w=width))
            yield s

    def setup_instance(self, d):
        if d in self._instance:
            logger.info(f'Instance {d} already set up')
            return

        logger.info(f'Setting up MC run instance {d}')

        # assume last two arguments in the copy command will be the source and
        # target directories
        #import pdb ; pdb.set_trace()
        cp = subprocess.run(self.copy_command+[self.base_sim_dir,d,])

        self._instance[d] = cp.returncode == 0

        if not self._instance[d]:
            raise RuntimeError(f'Problem setting up {d}')
        

    def run_instance(self, d):
        self.setup_instance(d)

        logger.verbose2(f'Running {d}')

        #import pdb ; pdb.set_trace()
        runner = PyPowerShellRunner(
                self.tc_command,
                simdir=d,
                timeout=600000.)

        returncode,stdout,stderr = runner.runSim()

        if returncode == 0:
            # try to keep all input files generated by makeMesh
            runner.eraseRunOutputs(keep=list( os.path.basename(f) for f in
                    chain( glob.glob(f'{d}{os.sep}*.grok'),
                        glob.glob(f'{d}{os.sep}*.[mf]props'),
                    )
                ))

        return returncode

    def _make_mc_run_tag(self,suff=''):
        """Return a name for this run (no suff) or MC instance (with suff)"""

        name = f'mc{"_dry" if self.DRY_RUN else ""}'\
               f'_{self.RUN_START.strftime("%Y%m%d_%H%M")}'

        if suff:
            name += f'_{suff}'

        return name

    def __str__(self):
        return self._make_mc_run_tag()

if __name__ == '__main__':

    ap = argparse.ArgumentParser()

    ap.add_argument( 'nRuns', type=int )

    ap.add_argument( 'base_sim', type=str,
        help="Directory containing the base simulation inputs."
        )

    ap.add_argument( '-v', '--verbose', default=1, action='count',
        help='Set verbosity. Default 1. Set to 0 for quiet, or higher for '\
            'increasing levels of chatter.'
        )

    ap.add_argument( '--num-processes', default=1, type=int,
        help="The maximum number of concurrent processes to use."
        )

    ap.add_argument( '--copy-command',
        default='hgs-copy-inputs.py',
        type=str,
        help='The name of the script or a shell command that clones the ' \
            'base simulation inputs in a MC directory. ' \
            'Note: in Windows environments, the PATHEXT environment ' \
            'variable may need to be modified for "uncommon" executable ' \
            'file extensions',
        )

    ap.add_argument( '--run-command',
        default='hgs-runall.ps1',
        type=str,
        help='The name of the script or a shell command that that invokes ' \
            'preprocessing, grok, pghs, hsplot, and postprocessing/cleanup' \
            'Note: in Windows environments, the PATHEXT environment ' \
            'variable may need to be modified for "uncommon" executable ' \
            'file extensions',
        )

    args = ap.parse_args()

    if args.verbose < 1:
        logger.setLevel(logging.WARN)
    elif args.verbose == 1:
        logger.setLevel(logging.INFO)
    else:
        logger.setLevel(logging.DEBUG)

    # check for base dir
    if not os.path.isdir(args.base_sim):
        print(f'Could not find base simulation directory "{args.base_sim}".',
            file=sys.stderr)
        sys.exit(-1)
    # autodetect the batch.pfx file
    if not 'batch.pfx' in os.listdir(args.base_sim):
        print(f'Could not find "{args.base_sim}{os.path.sep}batch.pfx".',
            file=sys.stderr)
        sys.exit(-1)

    # Check if other executable files exist
    # May need posix=False here, if retaining quotes in individual
    # parameters is important
    #import pdb ; pdb.set_trace()
    for f in [ args.copy_command, args.run_command ]:
        exe = shlex.split(f)[0]
        if os.access(exe,os.X_OK):
            pass
        elif shutil.which(exe):
            pass
        else:
            print(f'Could not find {exe}.', file=sys.stderr)
            sys.exit(-1)

    mc = HGS_MCRunner(args.copy_command, args.run_command, args.base_sim)

    # run
    if args.num_processes > 1:
        with Pool(args.num_processes) as p:
            p.map(mc.run_instance, mc.gen_mc_instances(args.nRuns))
    else:
        for r in mc.gen_mc_instances(args.nRuns):
            mc.run_instance(r)
